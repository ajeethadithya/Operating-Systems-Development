XINU is a small Unix-like operating system originally developed by Douglas Comer for instructional purposes at Purdue University. As part of lab assignment, I have re-implemented or improved some apsects of XINU.


1. Process Scheduling in XINU 

Exponential Distribution Scheduler:
	• The scheduler chooses the next process based on the random value generated by the exponential distribution.
	• The process with the lowest priority that is greater than the generated random value, is chosen.
	• Processes with the same priority are scheduled in a round-robin fashion.

Linux-like Scheduler:
	• Implemented a scheduler which is based on the Linux scheduler in the 2.2 kernel.
	• The CPU time consists of epochs, and in every epoch, each process is allowed to run up to a given time quantum.
	• The time quantum for each process is based on a goodness value, which is determined by the priority of the process and the remaining quantum from the previous epoch.


2. Demand Paging in XINU

• Demand paging is a method of mapping a large address space into a relatively small amount of physical memory, where pages are brought into the main memory on demand.
• A backing store which emulates the disk, is implemented with the physical memory, since the version of XINU used does not have file system support.
• A two-level page table is implemented to map 4GB of virtual space, onto 16MB of physical memory, where page tables are created and destructed on demand.
• Page fault handling routine has been implemented, along with page replacement policies such as Second Chance and AGING Page Replacement Policy.
• Implemented system calls for various functions such as memory management for multiple processes, in the backing store and physical memory.



3. Readers-Writer Locks in XINU

• Readers-Writer locks are used to synchronize access to a shared data structure.
• A lock acquired for reading can be shared by other readers, but a lock acquired for writing must be exclusive.
• Interactions between process synchronization and process scheduling causes priority inversion, which occurs when a higher priority thread is blocked waiting on a lock held by a lower priority thread.
• Implemented a priority inheritance mechanism to prevent the priority inversion problem when using locks, which also ensures the transitivity of priority inheritance.